[
  {
    "cell_type": "markdown",
    "metadata": {},
    "source": [
      "# Analyse neighborhoods of slide-seq spatial data with squidpy\n",
      "This notebook shows how to use common squidpy functions to analyse neighborhoods for slide-seq data."
    ]
  },
  {
    "cell_type": "code",
    "execution_count": null,
    "metadata": {},
    "outputs": [],
    "source": [
      "!pip install --upgrade pip\n",
      "!pip install pandas squidpy anndata hubmap_template_helper"
    ]
  },
  {
    "cell_type": "code",
    "execution_count": null,
    "metadata": {},
    "outputs": [],
    "source": [
      "# One of squidpy's functions depends on 'is_categorical_dtype' which generates a FutureWarning, \n",
      "# but as it's called many times, the notebook becomes crowded with this same warning. \n",
      "# This cell surpresses this warning.\n",
      "import warnings\n",
      "warnings.simplefilter(action='ignore', category=FutureWarning)"
    ]
  },
  {
    "cell_type": "code",
    "execution_count": null,
    "metadata": {},
    "outputs": [],
    "source": [
      "import requests\n",
      "import json\n",
      "\n",
      "import anndata as ad\n",
      "import squidpy as sq\n",
      "\n",
      "from hubmap_template_helper import uuids as hth_uuids\n",
      "from hubmap_template_helper import compatibility as hth_comp"
    ]
  },
  {
    "cell_type": "markdown",
    "metadata": {},
    "source": [
      "## Linked datasets\n",
      "The following datasets were symlinked to the workspace when this template was added:"
    ]
  },
  {
    "cell_type": "code",
    "execution_count": null,
    "metadata": {},
    "outputs": [],
    "source": [
      "# linked datasets\n",
      "uuids = {{ uuids | safe }}\n",
      "\n",
      "# accepted assay_display_names\n",
      "accepted_assay_display_names = ['Slide-seq [Salmon]']\n",
      "\n",
      "# search_api\n",
      "search_api = 'https://search.api.hubmapconsortium.org/v3/portal/search'"
    ]
  },
  {
    "cell_type": "markdown",
    "metadata": {},
    "source": [
      "This template is created for particular data types only. The following checks if the datasets are compatible with this template."
    ]
  },
  {
    "cell_type": "code",
    "execution_count": null,
    "metadata": {},
    "outputs": [],
    "source": [
      "uuids = hth_comp.check_template_compatibility(uuids, accepted_assay_display_names=accepted_assay_display_names, search_api=search_api)"
    ]
  },
  {
    "cell_type": "markdown",
    "metadata": {},
    "source": [
      "This notebook only shows the analysis for one sample. If more than one dataset are linked, the first is automatically selected, but can be changed below. "
    ]
  },
  {
    "cell_type": "code",
    "execution_count": null,
    "metadata": {},
    "outputs": [],
    "source": [
      "# selected dataset\n",
      "uuid = uuids[0]"
    ]
  },
  {
    "cell_type": "markdown",
    "metadata": {},
    "source": [
      "## Reading in data"
    ]
  },
  {
    "cell_type": "markdown",
    "metadata": {},
    "source": [
      "We first [read in](https://anndata.readthedocs.io/en/latest/generated/anndata.read_h5ad.html) the anndata of this dataset."
    ]
  },
  {
    "cell_type": "code",
    "execution_count": null,
    "metadata": {},
    "outputs": [],
    "source": [
      "adata = ad.read_h5ad('./datasets/' + uuid + '/secondary_analysis.h5ad')"
    ]
  },
  {
    "cell_type": "code",
    "execution_count": null,
    "metadata": {},
    "outputs": [],
    "source": [
      "adata"
    ]
  },
  {
    "cell_type": "markdown",
    "metadata": {},
    "source": [
      "## Squidpy analysis"
    ]
  },
  {
    "cell_type": "markdown",
    "metadata": {},
    "source": [
      "Based on the anndata object we set the spatial and cluster key. The spatial key should be available in obsm, and for most datasets it will be 'X_spatial'. The cluster key indicated the clusters we are interested in. Change this to e.g. Leiden to see another type of clustering. The cluster key should be available in obs."
    ]
  },
  {
    "cell_type": "code",
    "execution_count": null,
    "metadata": {},
    "outputs": [],
    "source": [
      "spatial_key = 'X_spatial'\n",
      "cluster_key = 'predicted_label'"
    ]
  },
  {
    "cell_type": "markdown",
    "metadata": {},
    "source": [
      "Most analyses with squidpy depend on the calculated spatial_connectivities and spatial_distances, which can be retrieved by [sq.gr.spatial_neighbors](https://squidpy.readthedocs.io/en/stable/api/squidpy.gr.spatial_neighbors.html#squidpy.gr.spatial_neighbors). This mutates the anndata object, so it doesn't return anything."
    ]
  },
  {
    "cell_type": "code",
    "execution_count": null,
    "metadata": {},
    "outputs": [],
    "source": [
      "sq.gr.spatial_neighbors(adata, coord_type='generic', spatial_key=spatial_key)"
    ]
  },
  {
    "cell_type": "code",
    "execution_count": null,
    "metadata": {},
    "outputs": [],
    "source": [
      "adata"
    ]
  },
  {
    "cell_type": "markdown",
    "metadata": {},
    "source": [
      "We can now look into neighborhood enrichment. We first calculate this with [sq.gr.nhood_enrichment](https://squidpy.readthedocs.io/en/stable/api/squidpy.gr.nhood_enrichment.html#squidpy.gr.nhood_enrichment), we can then plot this with [sq.pl.nhood_enrichment](https://squidpy.readthedocs.io/en/stable/api/squidpy.pl.nhood_enrichment.html#squidpy.pl.nhood_enrichment)."
    ]
  },
  {
    "cell_type": "code",
    "execution_count": null,
    "metadata": {},
    "outputs": [],
    "source": [
      "sq.gr.nhood_enrichment(adata, cluster_key=cluster_key)\n",
      "sq.pl.nhood_enrichment(adata, cluster_key=cluster_key)"
    ]
  },
  {
    "cell_type": "markdown",
    "metadata": {},
    "source": [
      "From this we can see the enrichment between our clusters."
    ]
  },
  {
    "cell_type": "markdown",
    "metadata": {},
    "source": [
      "These are now added to the anndata object under uns, though we could run the following to directly retrieve the z-scores:\n",
      "\n",
      "_Note that this is also possible for other functions, copy=True will return the calculated results directly, whereas the default copy=False will mutate the anndata object_"
    ]
  },
  {
    "cell_type": "code",
    "execution_count": null,
    "metadata": {},
    "outputs": [],
    "source": [
      "# z_scores = sq.gr.nhood_enrichment(adata, cluster_key='predicted_label', copy=True)\n",
      "# z_scores"
    ]
  },
  {
    "cell_type": "markdown",
    "metadata": {},
    "source": [
      "We can also look at the interaction matrix, by first running [sq.gr.interaction_matrix](https://squidpy.readthedocs.io/en/stable/api/squidpy.gr.interaction_matrix.html#squidpy.gr.interaction_matrix) and then plotting with [sq.pl.interaction_matrix](https://squidpy.readthedocs.io/en/stable/api/squidpy.pl.interaction_matrix.html#squidpy.pl.interaction_matrix). "
    ]
  },
  {
    "cell_type": "code",
    "execution_count": null,
    "metadata": {},
    "outputs": [],
    "source": [
      "sq.gr.interaction_matrix(adata,  cluster_key=cluster_key)\n",
      "sq.pl.interaction_matrix(adata,  cluster_key=cluster_key)"
    ]
  },
  {
    "cell_type": "markdown",
    "metadata": {},
    "source": [
      "Now we want to focus on one specific cell type or cluster, and calculate the co-occurrence with this celltype. We can use [sq.gr.co_occurrence](https://squidpy.readthedocs.io/en/stable/api/squidpy.gr.co_occurrence.html#squidpy.gr.co_occurrence) and [sq.pl.co_occurrence](https://squidpy.readthedocs.io/en/stable/api/squidpy.pl.co_occurrence.html#squidpy.pl.co_occurrence) for this."
    ]
  },
  {
    "cell_type": "code",
    "execution_count": null,
    "metadata": {},
    "outputs": [],
    "source": [
      "cluster_of_interest = 'neutrophil'\n",
      "\n",
      "sq.gr.co_occurrence(adata, spatial_key=spatial_key, cluster_key=cluster_key)\n",
      "sq.pl.co_occurrence(adata, cluster_key=cluster_key, clusters=cluster_of_interest)"
    ]
  },
  {
    "cell_type": "markdown",
    "metadata": {},
    "source": [
      "We can determine [Ripley's K- or L-function](https://en.wikipedia.org/wiki/Spatial_descriptive_statistics#Ripley's_K_and_L_functions) to calculate spatial homogeneity, with [sq.gr.ripley](https://squidpy.readthedocs.io/en/stable/api/squidpy.gr.ripley.html#squidpy.gr.ripley) and [sq.pl.ripley](https://squidpy.readthedocs.io/en/stable/api/squidpy.pl.ripley.html#squidpy.pl.ripley)."
    ]
  },
  {
    "cell_type": "code",
    "execution_count": null,
    "metadata": {},
    "outputs": [],
    "source": [
      "mode = 'L'\n",
      "sq.gr.ripley(adata, cluster_key=cluster_key, spatial_key=spatial_key, mode=mode, max_dist=500)\n",
      "sq.pl.ripley(adata, cluster_key=cluster_key, mode=mode)"
    ]
  }
]